<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Separate Operations Test</title>
    <style>
        body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
        pre { background: #0d0d1a; padding: 20px; overflow-x: auto; }
        button { margin: 5px; padding: 10px 20px; }
    </style>
</head>
<body>
    <h2>Separate Operations Test for Add12</h2>
    <p>Testing if splitting Add12 into separate kernels preserves error terms</p>
    <button onclick="runTest()">Run Test</button>
    <pre id="output">Click button to run test...</pre>

    <script type="module">
        function log(msg) {
            document.getElementById('output').textContent += msg + '\n';
        }

        window.runTest = async function() {
            document.getElementById('output').textContent = '';

            // Generate two random f32 values
            const a = Math.fround(Math.random());
            const b = Math.fround(Math.random());

            log('=== Input Values (f32) ===');
            log(`a: ${a}`);
            log(`b: ${b}`);
            log('');

            // JavaScript reference (in f64)
            const s_ref = a + b;
            const v_ref = s_ref - a;
            const r_ref = (a - (s_ref - v_ref)) + (b - v_ref);

            log('=== JavaScript f64 Reference ===');
            log(`s = a + b:              ${s_ref}`);
            log(`v = s - a:              ${v_ref}`);
            log(`s - v:                  ${s_ref - v_ref}`);
            log(`a - (s - v):            ${a - (s_ref - v_ref)}`);
            log(`b - v:                  ${b - v_ref}`);
            log(`r = (a-(s-v)) + (b-v):  ${r_ref}`);
            log('');

            // Check WebGPU
            if (!navigator.gpu) {
                log('WebGPU not available!');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
            if (!adapter) {
                log('No GPU adapter!');
                return;
            }

            const device = await adapter.requestDevice();

            // Create separate shaders for each operation
            const shader1 = device.createShaderModule({
                code: `
                    @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                    @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> output: array<f32>;

                    @compute @workgroup_size(1)
                    fn main() {
                        // Kernel 1: s = a + b
                        output[0] = inputA[0] + inputB[0];
                    }
                `
            });

            const shader2 = device.createShaderModule({
                code: `
                    @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                    @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> output: array<f32>;

                    @compute @workgroup_size(1)
                    fn main() {
                        // Kernel 2: v = s - a (inputA = s, inputB = a)
                        output[0] = inputA[0] - inputB[0];
                    }
                `
            });

            const shader3 = device.createShaderModule({
                code: `
                    @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                    @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> output: array<f32>;

                    @compute @workgroup_size(1)
                    fn main() {
                        // Kernel 3: compute s - v (inputA = s, inputB = v)
                        output[0] = inputA[0] - inputB[0];
                    }
                `
            });

            const shader4 = device.createShaderModule({
                code: `
                    @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                    @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> output: array<f32>;

                    @compute @workgroup_size(1)
                    fn main() {
                        // Kernel 4: compute a - (s-v) (inputA = a, inputB = s-v)
                        output[0] = inputA[0] - inputB[0];
                    }
                `
            });

            const shader5 = device.createShaderModule({
                code: `
                    @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                    @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> output: array<f32>;

                    @compute @workgroup_size(1)
                    fn main() {
                        // Kernel 5: compute b - v (inputA = b, inputB = v)
                        output[0] = inputA[0] - inputB[0];
                    }
                `
            });

            const shader6 = device.createShaderModule({
                code: `
                    @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                    @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> output: array<f32>;

                    @compute @workgroup_size(1)
                    fn main() {
                        // Kernel 6: compute (a-(s-v)) + (b-v) (inputA = a-(s-v), inputB = b-v)
                        output[0] = inputA[0] + inputB[0];
                    }
                `
            });

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                ]
            });

            const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });

            const pipeline1 = device.createComputePipeline({ layout: pipelineLayout, compute: { module: shader1, entryPoint: 'main' } });
            const pipeline2 = device.createComputePipeline({ layout: pipelineLayout, compute: { module: shader2, entryPoint: 'main' } });
            const pipeline3 = device.createComputePipeline({ layout: pipelineLayout, compute: { module: shader3, entryPoint: 'main' } });
            const pipeline4 = device.createComputePipeline({ layout: pipelineLayout, compute: { module: shader4, entryPoint: 'main' } });
            const pipeline5 = device.createComputePipeline({ layout: pipelineLayout, compute: { module: shader5, entryPoint: 'main' } });
            const pipeline6 = device.createComputePipeline({ layout: pipelineLayout, compute: { module: shader6, entryPoint: 'main' } });

            // Helper to run a compute shader
            async function runKernel(pipeline, inputAVal, inputBVal) {
                const inputA = device.createBuffer({
                    size: 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                const inputB = device.createBuffer({
                    size: 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                const outputBuffer = device.createBuffer({
                    size: 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                });
                const readBuffer = device.createBuffer({
                    size: 4,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
                });

                device.queue.writeBuffer(inputA, 0, new Float32Array([inputAVal]));
                device.queue.writeBuffer(inputB, 0, new Float32Array([inputBVal]));

                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: inputA } },
                        { binding: 1, resource: { buffer: inputB } },
                        { binding: 2, resource: { buffer: outputBuffer } },
                    ]
                });

                const commandEncoder = device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(pipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.dispatchWorkgroups(1);
                passEncoder.end();
                commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, 4);
                device.queue.submit([commandEncoder.finish()]);

                await readBuffer.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(readBuffer.getMappedRange().slice(0))[0];
                readBuffer.unmap();

                inputA.destroy();
                inputB.destroy();
                outputBuffer.destroy();
                readBuffer.destroy();

                return result;
            }

            // ========================================
            // Run Add12 step by step with separate kernels
            // ========================================
            log('=== WebGPU Separate Kernels ===');
            log('');

            // Step 1: s = a + b
            const s_gpu = await runKernel(pipeline1, a, b);
            log(`Kernel 1: s = a + b`);
            log(`  s = ${s_gpu}`);
            log('');

            // Step 2: v = s - a
            const v_gpu = await runKernel(pipeline2, s_gpu, a);
            log(`Kernel 2: v = s - a`);
            log(`  v = ${v_gpu}`);
            log('');

            // Step 3: s - v
            const s_minus_v_gpu = await runKernel(pipeline3, s_gpu, v_gpu);
            log(`Kernel 3: s - v`);
            log(`  s - v = ${s_minus_v_gpu}`);
            log('');

            // Step 4: a - (s - v)
            const a_minus_smv_gpu = await runKernel(pipeline4, a, s_minus_v_gpu);
            log(`Kernel 4: a - (s - v)`);
            log(`  a - (s-v) = ${a_minus_smv_gpu}`);
            log('');

            // Step 5: b - v
            const b_minus_v_gpu = await runKernel(pipeline5, b, v_gpu);
            log(`Kernel 5: b - v`);
            log(`  b - v = ${b_minus_v_gpu}`);
            log('');

            // Step 6: r = (a - (s-v)) + (b - v)
            const r_gpu = await runKernel(pipeline6, a_minus_smv_gpu, b_minus_v_gpu);
            log(`Kernel 6: r = (a-(s-v)) + (b-v)`);
            log(`  r = ${r_gpu}`);
            log('');

            // ========================================
            // Comparison
            // ========================================
            log('=== Comparison ===');
            log(`JS f64:  s = ${s_ref}, r = ${r_ref}`);
            log(`GPU:     s = ${s_gpu}, r = ${r_gpu}`);
            log('');
            log(`s + r (JS f64): ${s_ref + r_ref}`);
            log(`s + r (GPU):    ${s_gpu + r_gpu}`);
            log(`a + b (true):   ${a + b}`);
            log('');

            if (r_gpu !== 0) {
                log('✓ SUCCESS: Error term r is non-zero on GPU!');
                log(`  This means separate kernels prevent fast-math optimization.`);
            } else {
                log('✗ FAILURE: Error term r is still zero on GPU.');
                log(`  Fast-math is still eliminating the error term.`);
            }

            device.destroy();
        };
    </script>
</body>
</html>
