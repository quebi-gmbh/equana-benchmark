<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Mul22 Atomic Test</title>
    <style>
        body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
        pre { background: #0d0d1a; padding: 20px; overflow-x: auto; }
        button { margin: 5px; padding: 10px 20px; }
    </style>
</head>
<body>
    <h2>Mul22 with Atomic Operations</h2>
    <p>Full double-double multiplication: (ah, al) × (bh, bl) = (rh, rl)</p>
    <button onclick="runTest()">Run Test</button>
    <pre id="output">Click button to run test...</pre>

    <script type="module">
        function log(msg) {
            document.getElementById('output').textContent += msg + '\n';
        }

        // JavaScript reference implementations
        function Add12_js(a, b) {
            const s = a + b;
            const v = s - a;
            const r = (a - (s - v)) + (b - v);
            return { s, r };
        }

        function Split_js(a) {
            // For f64, use 2^27 + 1
            const SPLIT = 134217729.0;
            const c = SPLIT * a;
            const ahi = c - (c - a);
            const alo = a - ahi;
            return { hi: ahi, lo: alo };
        }

        function Mul12_js(a, b) {
            const x = a * b;
            const { hi: ahi, lo: alo } = Split_js(a);
            const { hi: bhi, lo: blo } = Split_js(b);
            const err1 = x - (ahi * bhi);
            const err2 = err1 - (alo * bhi);
            const err3 = err2 - (ahi * blo);
            const y = (alo * blo) - err3;
            return { x, y };
        }

        function Mul22_js(ah, al, bh, bl) {
            const { x: t1, y: t2 } = Mul12_js(ah, bh);
            const t3 = ((ah * bl) + (al * bh)) + t2;
            const { s: rh, r: rl } = Add12_js(t1, t3);
            return { rh, rl };
        }

        window.runTest = async function() {
            document.getElementById('output').textContent = '';

            // Generate two random f64 values and split them
            const a = Math.random();
            const b = Math.random();

            // Split into hi/lo (double-double representation)
            const a_hi = Math.fround(a);
            const a_lo = Math.fround(a - a_hi);
            const b_hi = Math.fround(b);
            const b_lo = Math.fround(b - b_hi);

            const true_product = a * b;

            log('=== Input Values ===');
            log(`a (f64):      ${a}`);
            log(`a.hi (f32):   ${a_hi}`);
            log(`a.lo (f32):   ${a_lo}`);
            log(`a.hi + a.lo:  ${a_hi + a_lo}`);
            log('');
            log(`b (f64):      ${b}`);
            log(`b.hi (f32):   ${b_hi}`);
            log(`b.lo (f32):   ${b_lo}`);
            log(`b.hi + b.lo:  ${b_hi + b_lo}`);
            log('');
            log(`True a×b:     ${true_product}`);
            log('');

            // JavaScript reference
            const { rh: rh_js, rl: rl_js } = Mul22_js(a_hi, a_lo, b_hi, b_lo);
            log('=== JavaScript f64 Reference (Mul22) ===');
            log(`rh:           ${rh_js}`);
            log(`rl:           ${rl_js}`);
            log(`rh + rl:      ${rh_js + rl_js}`);
            log(`Error:        ${true_product - (rh_js + rl_js)}`);
            log('');

            // Simple f32 multiply for comparison
            const simple_f32 = Math.fround(a_hi * b_hi);
            log('=== Simple f32 Multiply ===');
            log(`a.hi × b.hi:  ${simple_f32}`);
            log(`Error:        ${true_product - simple_f32}`);
            log('');

            // Check WebGPU
            if (!navigator.gpu) {
                log('WebGPU not available!');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
            if (!adapter) {
                log('No GPU adapter!');
                return;
            }

            const device = await adapter.requestDevice();

            // Full Mul22 implementation using atomic operations
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> inputA: array<f32>;  // [a.hi, a.lo]
                @group(0) @binding(1) var<storage, read> inputB: array<f32>;  // [b.hi, b.lo]
                @group(0) @binding(2) var<storage, read_write> temp: array<atomic<u32>>;
                @group(0) @binding(3) var<storage, read_write> output: array<f32>;

                // Atomic helpers to prevent fast-math optimization
                fn store(idx: u32, val: f32) {
                    atomicStore(&temp[idx], bitcast<u32>(val));
                }

                fn load(idx: u32) -> f32 {
                    return bitcast<f32>(atomicLoad(&temp[idx]));
                }

                // Add12: Error-free addition
                // Returns (s, r) where a + b = s + r exactly
                // Uses temp slots starting at 'base'
                fn Add12(a: f32, b: f32, base: u32) -> vec2<f32> {
                    // s = a + b
                    store(base, a + b);
                    let s = load(base);

                    // v = s - a
                    store(base + 1u, s - a);
                    let v = load(base + 1u);

                    // s - v
                    store(base + 2u, s - v);
                    let s_minus_v = load(base + 2u);

                    // a - (s - v)
                    store(base + 3u, a - s_minus_v);
                    let a_minus_smv = load(base + 3u);

                    // b - v
                    store(base + 4u, b - v);
                    let b_minus_v = load(base + 4u);

                    // r = (a - (s-v)) + (b - v)
                    store(base + 5u, a_minus_smv + b_minus_v);
                    let r = load(base + 5u);

                    return vec2<f32>(s, r);
                }

                // Split: Veltkamp splitting for f32
                // Split factor for f32 (24-bit mantissa): 2^12 + 1 = 4097
                fn Split(a: f32, base: u32) -> vec2<f32> {
                    let SPLIT_FACTOR: f32 = 4097.0;

                    // c = SPLIT * a
                    store(base, SPLIT_FACTOR * a);
                    let c = load(base);

                    // c - a
                    store(base + 1u, c - a);
                    let c_minus_a = load(base + 1u);

                    // ahi = c - (c - a)
                    store(base + 2u, c - c_minus_a);
                    let ahi = load(base + 2u);

                    // alo = a - ahi
                    store(base + 3u, a - ahi);
                    let alo = load(base + 3u);

                    return vec2<f32>(ahi, alo);
                }

                // Mul12: Error-free multiplication
                // Returns (x, y) where a * b = x + y exactly
                fn Mul12(a: f32, b: f32, base: u32) -> vec2<f32> {
                    // x = a * b
                    store(base, a * b);
                    let x = load(base);

                    // Split a (uses base+1 to base+4)
                    let sa = Split(a, base + 1u);
                    let ahi = sa.x;
                    let alo = sa.y;

                    // Split b (uses base+5 to base+8)
                    let sb = Split(b, base + 5u);
                    let bhi = sb.x;
                    let blo = sb.y;

                    // err1 = x - (ahi * bhi)
                    store(base + 9u, ahi * bhi);
                    let ahi_bhi = load(base + 9u);
                    store(base + 10u, x - ahi_bhi);
                    let err1 = load(base + 10u);

                    // err2 = err1 - (alo * bhi)
                    store(base + 11u, alo * bhi);
                    let alo_bhi = load(base + 11u);
                    store(base + 12u, err1 - alo_bhi);
                    let err2 = load(base + 12u);

                    // err3 = err2 - (ahi * blo)
                    store(base + 13u, ahi * blo);
                    let ahi_blo = load(base + 13u);
                    store(base + 14u, err2 - ahi_blo);
                    let err3 = load(base + 14u);

                    // y = (alo * blo) - err3
                    store(base + 15u, alo * blo);
                    let alo_blo = load(base + 15u);
                    store(base + 16u, alo_blo - err3);
                    let y = load(base + 16u);

                    return vec2<f32>(x, y);
                }

                // Mul22: Double-double multiplication
                // (ah, al) * (bh, bl) = (rh, rl)
                fn Mul22(ah: f32, al: f32, bh: f32, bl: f32, base: u32) -> vec2<f32> {
                    // (t1, t2) = Mul12(ah, bh)
                    let t = Mul12(ah, bh, base);
                    let t1 = t.x;
                    let t2 = t.y;

                    // ah * bl
                    store(base + 20u, ah * bl);
                    let ah_bl = load(base + 20u);

                    // al * bh
                    store(base + 21u, al * bh);
                    let al_bh = load(base + 21u);

                    // (ah * bl) + (al * bh)
                    store(base + 22u, ah_bl + al_bh);
                    let sum1 = load(base + 22u);

                    // t3 = sum1 + t2
                    store(base + 23u, sum1 + t2);
                    let t3 = load(base + 23u);

                    // (rh, rl) = Add12(t1, t3)
                    let result = Add12(t1, t3, base + 24u);

                    return result;
                }

                @compute @workgroup_size(1)
                fn main() {
                    let ah = inputA[0];
                    let al = inputA[1];
                    let bh = inputB[0];
                    let bl = inputB[1];

                    // Compute Mul22
                    let result = Mul22(ah, al, bh, bl, 0u);

                    output[0] = result.x;  // rh
                    output[1] = result.y;  // rl

                    // Also output intermediate values for debugging
                    // Simple f32 multiply for comparison
                    store(50u, ah * bh);
                    output[2] = load(50u);
                }
            `;

            const shaderModule = device.createShaderModule({ code: shaderCode });

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                ]
            });

            const pipeline = device.createComputePipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                compute: { module: shaderModule, entryPoint: 'main' }
            });

            // Create buffers
            const inputA = device.createBuffer({
                size: 2 * 4,  // [a.hi, a.lo]
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            const inputB = device.createBuffer({
                size: 2 * 4,  // [b.hi, b.lo]
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            const tempBuffer = device.createBuffer({
                size: 64 * 4,  // plenty of temp storage
                usage: GPUBufferUsage.STORAGE,
            });
            const outputBuffer = device.createBuffer({
                size: 4 * 4,  // [rh, rl, simple_f32, ...]
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            const readBuffer = device.createBuffer({
                size: 4 * 4,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            });

            device.queue.writeBuffer(inputA, 0, new Float32Array([a_hi, a_lo]));
            device.queue.writeBuffer(inputB, 0, new Float32Array([b_hi, b_lo]));

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: inputA } },
                    { binding: 1, resource: { buffer: inputB } },
                    { binding: 2, resource: { buffer: tempBuffer } },
                    { binding: 3, resource: { buffer: outputBuffer } },
                ]
            });

            const commandEncoder = device.createCommandEncoder();
            const passEncoder = commandEncoder.beginComputePass();
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.dispatchWorkgroups(1);
            passEncoder.end();
            commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, 4 * 4);
            device.queue.submit([commandEncoder.finish()]);

            await readBuffer.mapAsync(GPUMapMode.READ);
            const result = new Float32Array(readBuffer.getMappedRange().slice(0));
            readBuffer.unmap();

            const rh_gpu = result[0];
            const rl_gpu = result[1];
            const simple_gpu = result[2];

            log('=== WebGPU Mul22 (Atomic Operations) ===');
            log(`rh:           ${rh_gpu}`);
            log(`rl:           ${rl_gpu}`);
            log(`rh + rl:      ${rh_gpu + rl_gpu}`);
            log(`Error:        ${true_product - (rh_gpu + rl_gpu)}`);
            log('');

            log('=== WebGPU Simple f32 ===');
            log(`a.hi × b.hi:  ${simple_gpu}`);
            log(`Error:        ${true_product - simple_gpu}`);
            log('');

            // Comparison
            log('=== Error Comparison ===');
            const err_simple = Math.abs(true_product - simple_gpu);
            const err_mul22 = Math.abs(true_product - (rh_gpu + rl_gpu));

            log(`Simple f32 error: ${err_simple.toExponential(4)}`);
            log(`Mul22 error:      ${err_mul22.toExponential(4)}`);
            log('');

            if (err_mul22 < err_simple) {
                const improvement = err_simple / err_mul22;
                log(`✓ Mul22 is ${improvement.toFixed(1)}x more accurate than simple f32!`);
            } else if (err_mul22 === 0) {
                log(`✓ Mul22 achieved exact result!`);
            } else {
                log(`✗ Mul22 did not improve accuracy.`);
            }

            inputA.destroy();
            inputB.destroy();
            tempBuffer.destroy();
            outputBuffer.destroy();
            readBuffer.destroy();
            device.destroy();
        };
    </script>
</body>
</html>
