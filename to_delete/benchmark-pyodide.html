<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Pyodide NumPy MatMul Benchmark</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            max-width: 1000px;
            margin: 50px auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 { color: #00d4ff; }
        h2 { color: #00d4ff; margin-top: 30px; }
        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            font-size: 14px;
            cursor: pointer;
            margin: 5px;
            border-radius: 4px;
        }
        button:hover { background: #00b8e6; }
        button:disabled { background: #555; cursor: not-allowed; }
        #output {
            background: #0d0d1a;
            border: 1px solid #333;
            padding: 20px;
            margin-top: 20px;
            white-space: pre-wrap;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 13px;
            max-height: 700px;
            overflow-y: auto;
        }
        .result { color: #00ff88; font-weight: bold; }
        .warn { color: #ff6b6b; }
        .info { color: #888; }
        .highlight { color: #ffcc00; font-weight: bold; }
        select {
            background: #0d0d1a;
            color: #eee;
            border: 1px solid #333;
            padding: 8px;
            margin: 5px;
        }
        .section {
            margin: 10px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 4px;
        }
        #loading {
            display: none;
            color: #00d4ff;
            margin: 10px 0;
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-top: 3px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Pyodide NumPy MatMul Benchmark</h1>
    <p>Running NumPy matrix multiplication in WebAssembly via Pyodide</p>

    <div class="section">
        <label>Matrix Size (N×N):
            <select id="size">
                <option value="128">128</option>
                <option value="256">256</option>
                <option value="512" selected>512</option>
                <option value="750">750</option>
                <option value="1000">1000</option>
            </select>
        </label>
        <label>Rounds:
            <select id="rounds">
                <option value="1">1</option>
                <option value="3" selected>3</option>
                <option value="5">5</option>
            </select>
        </label>
        <button id="runBtn" onclick="runBenchmark()">Run Benchmark</button>
        <button onclick="clearLog()">Clear</button>
    </div>

    <div id="loading">
        <span class="spinner"></span>
        <span id="loadingText">Loading Pyodide...</span>
    </div>

    <div id="output"><span class="info">Click "Run Benchmark" to start. First run will load Pyodide (~15MB).</span></div>

    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.0/full/pyodide.js"></script>
    <script>
        let pyodide = null;

        function log(msg, cls = '') {
            const output = document.getElementById('output');
            if (cls) {
                output.innerHTML += `<span class="${cls}">${msg}</span>\n`;
            } else {
                output.innerHTML += msg + '\n';
            }
            output.scrollTop = output.scrollHeight;
        }

        function clearLog() {
            document.getElementById('output').innerHTML = '';
        }

        function setLoading(show, text = 'Loading...') {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('loadingText').textContent = text;
            document.getElementById('runBtn').disabled = show;
        }

        async function loadPyodideIfNeeded() {
            if (pyodide) return pyodide;

            setLoading(true, 'Loading Pyodide runtime (~15MB)...');
            log('Loading Pyodide...', 'info');

            pyodide = await loadPyodide();
            log('Pyodide loaded!', 'result');

            setLoading(true, 'Loading NumPy...');
            log('Loading NumPy package...', 'info');

            await pyodide.loadPackage('numpy');
            log('NumPy loaded!', 'result');

            // Get NumPy info
            const npInfo = pyodide.runPython(`
import numpy as np
f"NumPy version: {np.__version__}"
            `);
            log(npInfo, 'info');

            setLoading(false);
            return pyodide;
        }

        async function runBenchmark() {
            clearLog();

            const N = parseInt(document.getElementById('size').value);
            const rounds = parseInt(document.getElementById('rounds').value);
            const gflop = 2 * N * N * N / 1e9;

            log('═'.repeat(70), 'highlight');
            log('  Pyodide NumPy MatMul Benchmark', 'highlight');
            log('═'.repeat(70), 'highlight');
            log('');
            log(`Matrix size: ${N}×${N}`, 'info');
            log(`FLOP per matmul: ${gflop.toFixed(3)} GFLOP`, 'info');
            log(`Rounds: ${rounds}`, 'info');
            log('');

            try {
                await loadPyodideIfNeeded();

                setLoading(true, 'Running benchmark...');

                // Run the benchmark
                const result = await pyodide.runPythonAsync(`
import numpy as np
import time

N = ${N}
rounds = ${rounds}

# Create random matrices
print("Creating random matrices...")
A = np.random.rand(N, N).astype(np.float64)
B = np.random.rand(N, N).astype(np.float64)

# Warmup
print("Warmup...")
_ = A @ B

# Timed rounds
times = []
for i in range(rounds):
    start = time.perf_counter()
    C = A @ B
    elapsed = time.perf_counter() - start
    times.append(elapsed)
    print(f"Round {i+1}: {elapsed*1000:.2f} ms")

avg = np.mean(times)
gflops = 2 * N**3 / avg / 1e9

# Return results as dict
{
    'avg': float(avg),
    'gflops': float(gflops),
    'times': [float(t) for t in times],
    'sample_value': float(C[0, 0])
}
                `);

                const pyResult = result.toJs();

                setLoading(false);

                log('');
                log('─'.repeat(60));
                log('RESULTS', 'highlight');
                log('─'.repeat(60));
                log('');

                const timesStr = pyResult.get('times').map(t => `${(t * 1000).toFixed(2)}ms`).join(', ');
                const avg = pyResult.get('avg');
                const gflops = pyResult.get('gflops');

                log(`Times: ${timesStr}`);
                log(`Average: ${(avg * 1000).toFixed(2)} ms`, 'result');
                log(`Performance: ${gflops.toFixed(2)} GFLOPS`, 'result');

                log('');
                log('─'.repeat(60));
                log('COMPARISON WITH NATIVE', 'highlight');
                log('─'.repeat(60));
                log('');

                // Reference values from benchmarks
                // Native SSE3 (single-threaded OpenBLAS with OPENBLAS_CORETYPE=PRESCOTT)
                // Custom WASM SIMD (our optimized 4x4 implementation with SIMD128)
                const refs = N === 512 ? {
                    nativeSSE: { time: 9.53, gflops: 28.17 },
                    wasmSIMD: { time: 7.40, gflops: 36.28 }  // Actual benchmark results
                } : N === 1000 ? {
                    nativeSSE: { time: 74.5, gflops: 26.85 },
                    wasmSIMD: { time: 55, gflops: 36.4 }  // Extrapolated from 512x512
                } : N === 256 ? {
                    nativeSSE: { time: 1.2, gflops: 27.9 },
                    wasmSIMD: { time: 0.95, gflops: 35.2 }  // Extrapolated
                } : N === 750 ? {
                    nativeSSE: { time: 32, gflops: 26.4 },
                    wasmSIMD: { time: 23, gflops: 36.7 }  // Extrapolated
                } : null;

                if (refs) {
                    const ratioNative = (avg * 1000) / refs.nativeSSE.time;
                    const ratioWasm = (avg * 1000) / refs.wasmSIMD.time;

                    log('Reference implementations:', 'info');
                    log(`  Native NumPy (SSE3, 1 thread):  ${refs.nativeSSE.time.toFixed(2)} ms (${refs.nativeSSE.gflops.toFixed(2)} GFLOPS)`, 'info');
                    log(`  Custom WASM SIMD (our code):    ~${refs.wasmSIMD.time.toFixed(0)} ms (~${refs.wasmSIMD.gflops.toFixed(1)} GFLOPS)`, 'info');
                    log(`  Pyodide NumPy (scalar WASM):    ${(avg * 1000).toFixed(2)} ms (${gflops.toFixed(2)} GFLOPS)`, 'info');
                    log('');
                    log(`Pyodide is ${ratioNative.toFixed(1)}x slower than native SSE3`, 'warn');
                    log(`Pyodide is ${ratioWasm.toFixed(1)}x slower than our WASM SIMD`, 'warn');
                    log('');
                    log(`Our WASM SIMD is ${(refs.nativeSSE.gflops / refs.wasmSIMD.gflops).toFixed(1)}x slower than native SSE3`, 'info');
                }

                log('');
                log('Why Pyodide NumPy is slow:', 'highlight');
                log('  • OpenBLAS compiled to scalar WASM (no SIMD128)', 'info');
                log('  • No multi-threading in WebAssembly', 'info');
                log('  • Python interpreter overhead in WASM', 'info');
                log('');
                log('Why our WASM SIMD is faster:', 'highlight');
                log('  • Uses WASM SIMD128 (f64x2 vectors = 2 doubles)', 'info');
                log('  • Cache-optimized blocking + packing', 'info');
                log('  • Hand-tuned micro-kernels', 'info');

                // Also run a pure Python (no NumPy) naive matmul for comparison
                if (N <= 256) {
                    log('');
                    log('─'.repeat(60));
                    log('BONUS: Pure Python (no NumPy) naive matmul', 'highlight');
                    log('─'.repeat(60));
                    log('');

                    setLoading(true, 'Running pure Python benchmark...');

                    const pureResult = await pyodide.runPythonAsync(`
import time

N = ${Math.min(N, 128)}  # Limit size for pure Python

# Create lists
A_list = [[i * N + j for j in range(N)] for i in range(N)]
B_list = [[i * N + j for j in range(N)] for i in range(N)]

def matmul_pure(A, B, N):
    C = [[0.0] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            s = 0.0
            for k in range(N):
                s += A[i][k] * B[k][j]
            C[i][j] = s
    return C

# Time it (just once for pure Python)
start = time.perf_counter()
C_pure = matmul_pure(A_list, B_list, N)
elapsed = time.perf_counter() - start

gflops_pure = 2 * N**3 / elapsed / 1e9

{
    'time': float(elapsed),
    'gflops': float(gflops_pure),
    'N': N
}
                    `);

                    setLoading(false);

                    const pureRes = pureResult.toJs();
                    const pureN = pureRes.get('N');
                    const pureTime = pureRes.get('time');
                    const pureGflops = pureRes.get('gflops');

                    log(`Matrix size: ${pureN}×${pureN}`, 'info');
                    log(`Time: ${(pureTime * 1000).toFixed(2)} ms`, 'info');
                    log(`Performance: ${pureGflops.toFixed(4)} GFLOPS`, 'info');

                    if (pureN === N) {
                        const speedup = pureTime / avg;
                        log('');
                        log(`NumPy speedup over pure Python: ${speedup.toFixed(0)}x`, 'result');
                    }
                }

            } catch (e) {
                setLoading(false);
                log(`Error: ${e.message}`, 'warn');
                console.error(e);
            }
        }
    </script>
</body>
</html>
