<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Multithreaded WASM MatMul Benchmark</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            max-width: 1000px;
            margin: 50px auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 { color: #00d4ff; }
        h2 { color: #00d4ff; margin-top: 30px; }
        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            font-size: 14px;
            cursor: pointer;
            margin: 5px;
            border-radius: 4px;
        }
        button:hover { background: #00b8e6; }
        button:disabled { background: #555; cursor: not-allowed; }
        #output {
            background: #0d0d1a;
            border: 1px solid #333;
            padding: 20px;
            margin-top: 20px;
            white-space: pre-wrap;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 13px;
            max-height: 700px;
            overflow-y: auto;
        }
        .result { color: #00ff88; font-weight: bold; }
        .warn { color: #ff6b6b; }
        .info { color: #888; }
        .highlight { color: #ffcc00; font-weight: bold; }
        select, input {
            background: #0d0d1a;
            color: #eee;
            border: 1px solid #333;
            padding: 8px;
            margin: 5px;
        }
        .section {
            margin: 10px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 4px;
        }
        #loading {
            display: none;
            color: #00d4ff;
            margin: 10px 0;
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-top: 3px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-box {
            background: #2a1a1a;
            border: 1px solid #ff6b6b;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Multithreaded WASM MatMul Benchmark</h1>
    <p>Comparing single-threaded vs multi-threaded WASM SIMD matrix multiplication</p>

    <div class="section">
        <label>Matrix Size (N×N):
            <select id="size">
                <option value="128">128</option>
                <option value="256">256</option>
                <option value="512" selected>512</option>
                <option value="1000">1000</option>
                <option value="2000">2000</option>
            </select>
        </label>
        <label>Threads:
            <select id="threads">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="4" selected>4</option>
                <option value="8">8</option>
                <option value="16">16</option>
                <option value="auto">Auto (navigator.hardwareConcurrency)</option>
            </select>
        </label>
        <label>Rounds:
            <select id="rounds">
                <option value="1">1</option>
                <option value="3" selected>3</option>
                <option value="5">5</option>
            </select>
        </label>
        <label style="margin-left: 15px;">
            <input type="checkbox" id="useWorker"> Run WASM in Web Worker
        </label>
        <br><br>
        <button id="runBtn" onclick="runBenchmark()">Run Benchmark</button>
        <button onclick="clearLog()">Clear</button>
    </div>

    <div id="sab-warning" class="error-box" style="display: none;">
        <strong>⚠️ SharedArrayBuffer not available!</strong><br><br>
        Multithreaded WebAssembly requires SharedArrayBuffer, which needs special HTTP headers:<br>
        <code>Cross-Origin-Embedder-Policy: require-corp</code><br>
        <code>Cross-Origin-Opener-Policy: same-origin</code><br><br>
        Use the included server: <code>python3 server_mt.py</code>
    </div>

    <div id="loading">
        <span class="spinner"></span>
        <span id="loadingText">Loading...</span>
    </div>

    <div id="output"><span class="info">Click "Run Benchmark" to start.</span></div>

    <script>
        // Check SharedArrayBuffer support
        if (typeof SharedArrayBuffer === 'undefined') {
            document.getElementById('sab-warning').style.display = 'block';
        }

        let wasmST = null;  // Single-threaded module
        let wasmMT = null;  // Multi-threaded module
        let wasmSSE_MT = null;  // SSE-style multi-threaded module
        let wasmWorker = null;  // Web Worker for isolated WASM execution
        let numwaModule = null;  // numwa BLAS module (ST only)
        let numwaMTModule = null;  // numwa BLAS MT module
        let standaloneModule = null;  // Standalone single-TU SSE module

        function log(msg, cls = '') {
            const output = document.getElementById('output');
            if (cls) {
                output.innerHTML += `<span class="${cls}">${msg}</span>\n`;
            } else {
                output.innerHTML += msg + '\n';
            }
            output.scrollTop = output.scrollHeight;
        }

        function clearLog() {
            document.getElementById('output').innerHTML = '';
        }

        function setLoading(show, text = 'Loading...') {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('loadingText').textContent = text;
            document.getElementById('runBtn').disabled = show;
        }

        // Compute relative error (same as benchmark-wasm.html)
        function computeError(ref, test) {
            let sumErr = 0;
            let count = 0;
            const len = ref.length || ref.byteLength / 8;
            for (let i = 0; i < len; i++) {
                const r = ref[i];
                const t = test[i];
                if (Math.abs(r) > 1e-10) {
                    sumErr += Math.abs((r - t) / r);
                    count++;
                }
            }
            return count > 0 ? sumErr / count : 0;
        }

        // Load single-threaded WASM (existing optimized version)
        async function loadSingleThreaded() {
            if (wasmST) return wasmST;

            const response = await fetch('matmul_full_4x4.wasm');
            const bytes = await response.arrayBuffer();

            // The WASM module has its own internal memory (256MB initial)
            // We only need to provide the emscripten_notify_memory_growth callback
            const { instance } = await WebAssembly.instantiate(bytes, {
                env: {
                    // Callback when WASM memory grows
                    emscripten_notify_memory_growth: function(memoryIndex) {
                        // Memory was grown - nothing special needed
                    }
                }
            });
            wasmST = instance.exports;
            return wasmST;
        }

        // Load multi-threaded WASM
        async function loadMultiThreaded() {
            if (wasmMT) return wasmMT;

            // Import the Emscripten-generated JS module
            return new Promise((resolve, reject) => {
                // Set up Module object BEFORE loading the script
                window.Module = {
                    onRuntimeInitialized: function() {
                        console.log('MT WASM initialized');
                        console.log('Module.HEAPF64:', Module.HEAPF64);

                        wasmMT = {
                            matmul_f64_mt: Module._matmul_f64_mt,
                            set_num_threads: Module._set_num_threads,
                            get_num_threads: Module._get_num_threads,
                            malloc_f64: Module._malloc_f64,
                            free_f64: Module._free_f64,
                            cleanup: Module._cleanup,
                            // Get fresh HEAPF64 view (handles memory growth)
                            getHeap: () => Module.HEAPF64
                        };
                        resolve(wasmMT);
                    }
                };

                const script = document.createElement('script');
                script.src = 'matmul_mt.js';
                script.onerror = (e) => reject(new Error('Failed to load matmul_mt.js'));
                document.head.appendChild(script);
            });
        }

        // Load SSE-style multi-threaded WASM (modularized build)
        async function loadSSE_MT() {
            if (wasmSSE_MT) return wasmSSE_MT;

            return new Promise((resolve, reject) => {
                // Load the modularized script
                const script = document.createElement('script');
                script.src = 'matmul_sse_mt.js';
                script.onerror = (e) => reject(new Error('Failed to load matmul_sse_mt.js'));
                script.onload = async () => {
                    try {
                        // createSSEModule is the factory function from MODULARIZE=1
                        const sseModule = await createSSEModule();
                        console.log('SSE MT WASM initialized');

                        wasmSSE_MT = {
                            matmul_sse_mt: sseModule._matmul_sse_mt,
                            set_num_threads: sseModule._set_num_threads,
                            get_num_threads: sseModule._get_num_threads,
                            malloc_f64: sseModule._malloc_f64,
                            free_f64: sseModule._free_f64,
                            cleanup: sseModule._cleanup,
                            getHeap: () => sseModule.HEAPF64
                        };

                        window.Module_SSE = sseModule;
                        resolve(wasmSSE_MT);
                    } catch (e) {
                        reject(e);
                    }
                };
                document.head.appendChild(script);
            });
        }

        // Load numwa BLAS module (Emscripten modularized build, single-threaded)
        async function loadNumwaModule() {
            if (numwaModule) return numwaModule;

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'numwa/blas.cjs';
                script.onerror = () => reject(new Error('Failed to load numwa blas.cjs'));
                script.onload = async () => {
                    try {
                        // createBLASModule is the factory from Emscripten MODULARIZE
                        const module = await createBLASModule();
                        numwaModule = {
                            module,
                            matmul_f64: module._matmul_f64,
                            matmul_f64_sse: module._matmul_f64_sse,
                            matmul_f64_native: module._matmul_f64_native,
                            malloc_f64: module._malloc_f64,
                            free_f64: module._free_f64,
                            cleanup: module._cleanup,
                            getHeap: () => module.HEAPF64
                        };
                        resolve(numwaModule);
                    } catch (e) {
                        reject(e);
                    }
                };
                document.head.appendChild(script);
            });
        }

        // Load numwa BLAS MT module (multi-threaded version)
        async function loadNumwaMTModule() {
            if (numwaMTModule) return numwaMTModule;

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'numwa/blas_mt.js';
                script.onerror = () => reject(new Error('Failed to load numwa blas_mt.js'));
                script.onload = async () => {
                    try {
                        // createBLASMTModule is the factory from Emscripten MODULARIZE
                        const module = await createBLASMTModule();
                        numwaMTModule = {
                            module,
                            matmul_f64_mt: module._matmul_f64_mt,
                            matmul_f64_sse_mt: module._matmul_f64_sse_mt,
                            set_num_threads: module._set_num_threads,
                            get_num_threads: module._get_num_threads,
                            malloc_f64: module._malloc_f64,
                            free_f64: module._free_f64,
                            cleanup: module._cleanup,
                            getHeap: () => module.HEAPF64
                        };
                        resolve(numwaMTModule);
                    } catch (e) {
                        reject(e);
                    }
                };
                document.head.appendChild(script);
            });
        }

        // Load standalone single-TU SSE module (for testing inlining hypothesis)
        async function loadStandaloneModule() {
            if (standaloneModule) return standaloneModule;

            const { default: createModule } = await import('./numwa/matmul_standalone.mjs');
            const module = await createModule();
            standaloneModule = {
                module,
                matmul_standalone: module._matmul_standalone,
                malloc_f64: module._malloc_f64,
                free_f64: module._free_f64,
                cleanup: module._cleanup,
                getHeap: () => module.HEAPF64
            };
            return standaloneModule;
        }

        // Load standalone MT single-TU SSE module
        let standaloneMTModule = null;
        async function loadStandaloneMTModule() {
            if (standaloneMTModule) return standaloneMTModule;

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'numwa/matmul_standalone_mt.js';
                script.onerror = () => reject(new Error('Failed to load matmul_standalone_mt.js'));
                script.onload = async () => {
                    try {
                        const module = await createStandaloneMTModule();
                        standaloneMTModule = {
                            module,
                            matmul_standalone_mt: module._matmul_standalone_mt,
                            set_num_threads: module._set_num_threads,
                            get_num_threads: module._get_num_threads,
                            malloc_f64: module._malloc_f64,
                            free_f64: module._free_f64,
                            cleanup: module._cleanup,
                            getHeap: () => module.HEAPF64
                        };
                        resolve(standaloneMTModule);
                    } catch (e) {
                        reject(e);
                    }
                };
                document.head.appendChild(script);
            });
        }

        // Benchmark numwa MT module
        async function benchNumwaMT(numwa, funcName, N, A, B, rounds, nthreads) {
            numwa.set_num_threads(nthreads);

            const size = N * N;
            const ptrA = numwa.malloc_f64(size);
            const ptrB = numwa.malloc_f64(size);
            const ptrC = numwa.malloc_f64(size);

            const offsetA = ptrA / 8;
            const offsetB = ptrB / 8;
            const offsetC = ptrC / 8;

            let heap = numwa.getHeap();
            for (let i = 0; i < size; i++) {
                heap[offsetA + i] = A[i];
                heap[offsetB + i] = B[i];
            }

            const func = numwa[funcName];

            // Warmup
            func(N, N, N, ptrA, ptrB, ptrC);
            await new Promise(r => setTimeout(r, 100));

            const times = [];
            for (let r = 0; r < rounds; r++) {
                const start = performance.now();
                func(N, N, N, ptrA, ptrB, ptrC);
                times.push(performance.now() - start);
            }

            heap = numwa.getHeap();
            const C = new Float64Array(size);
            for (let i = 0; i < size; i++) {
                C[i] = heap[offsetC + i];
            }

            numwa.free_f64(ptrA);
            numwa.free_f64(ptrB);
            numwa.free_f64(ptrC);

            return {
                times,
                avg: times.reduce((a, b) => a + b) / times.length,
                C
            };
        }

        // Benchmark numwa BLAS module (single-threaded)
        async function benchNumwa(numwa, funcName, N, A, B, rounds) {
            const size = N * N;
            const ptrA = numwa.malloc_f64(size);
            const ptrB = numwa.malloc_f64(size);
            const ptrC = numwa.malloc_f64(size);

            const offsetA = ptrA / 8;
            const offsetB = ptrB / 8;
            const offsetC = ptrC / 8;

            let heap = numwa.getHeap();
            for (let i = 0; i < size; i++) {
                heap[offsetA + i] = A[i];
                heap[offsetB + i] = B[i];
            }

            const func = numwa[funcName];

            // Warmup
            func(N, N, N, ptrA, ptrB, ptrC);

            const times = [];
            for (let r = 0; r < rounds; r++) {
                const start = performance.now();
                func(N, N, N, ptrA, ptrB, ptrC);
                times.push(performance.now() - start);
            }

            heap = numwa.getHeap();
            const C = new Float64Array(size);
            for (let i = 0; i < size; i++) {
                C[i] = heap[offsetC + i];
            }

            numwa.free_f64(ptrA);
            numwa.free_f64(ptrB);
            numwa.free_f64(ptrC);

            return {
                times,
                avg: times.reduce((a, b) => a + b) / times.length,
                C
            };
        }

        // Initialize web worker for WASM
        async function initWorker() {
            if (wasmWorker) return wasmWorker;

            return new Promise((resolve, reject) => {
                wasmWorker = new Worker('matmul-worker.js');

                wasmWorker.onmessage = function(e) {
                    if (e.data.type === 'ready') {
                        resolve(wasmWorker);
                    } else if (e.data.type === 'error') {
                        reject(new Error(e.data.error));
                    }
                };

                wasmWorker.onerror = function(e) {
                    reject(new Error('Worker error: ' + e.message));
                };

                wasmWorker.postMessage({ type: 'init' });
            });
        }

        // Benchmark WASM in web worker
        async function benchWorker(N, A, B, rounds) {
            const worker = await initWorker();

            return new Promise((resolve, reject) => {
                worker.onmessage = function(e) {
                    if (e.data.type === 'result') {
                        resolve({
                            times: e.data.times,
                            avg: e.data.avg,
                            C: new Float64Array(e.data.C)
                        });
                    } else if (e.data.type === 'error') {
                        reject(new Error(e.data.error));
                    }
                };

                // Transfer the array buffers for efficiency
                worker.postMessage({
                    type: 'benchmark',
                    N,
                    A: Array.from(A),  // Convert to regular array for transfer
                    B: Array.from(B),
                    rounds
                });
            });
        }

        // Benchmark single-threaded WASM
        async function benchST(wasm, N, A, B, rounds) {
            const exports = wasm;

            // Allocate memory
            const ptrA = exports.malloc_f64(N * N);
            const ptrB = exports.malloc_f64(N * N);
            const ptrC = exports.malloc_f64(N * N);

            // Copy data
            const mem = new Float64Array(exports.memory.buffer);
            const offsetA = ptrA / 8;
            const offsetB = ptrB / 8;
            const offsetC = ptrC / 8;

            for (let i = 0; i < N * N; i++) {
                mem[offsetA + i] = A[i];
                mem[offsetB + i] = B[i];
            }

            // Warmup
            exports.matmul_f64(N, N, N, ptrA, ptrB, ptrC);

            // Timed runs
            const times = [];
            for (let r = 0; r < rounds; r++) {
                const start = performance.now();
                exports.matmul_f64(N, N, N, ptrA, ptrB, ptrC);
                times.push(performance.now() - start);
            }

            // Copy result matrix C
            const C = new Float64Array(N * N);
            for (let i = 0; i < N * N; i++) {
                C[i] = mem[offsetC + i];
            }

            // Cleanup
            exports.free_f64(ptrA);
            exports.free_f64(ptrB);
            exports.free_f64(ptrC);

            return {
                times,
                avg: times.reduce((a, b) => a + b) / times.length,
                C
            };
        }

        // Benchmark multi-threaded WASM
        async function benchMT(wasm, N, A, B, rounds, nthreads) {
            // Set number of threads
            wasm.set_num_threads(nthreads);

            // Allocate memory in WASM heap
            const ptrA = wasm.malloc_f64(N * N);
            const ptrB = wasm.malloc_f64(N * N);
            const ptrC = wasm.malloc_f64(N * N);

            // Copy data to WASM memory
            const offsetA = ptrA / 8;
            const offsetB = ptrB / 8;
            const offsetC = ptrC / 8;

            let heap = wasm.getHeap();
            for (let i = 0; i < N * N; i++) {
                heap[offsetA + i] = A[i];
                heap[offsetB + i] = B[i];
            }

            // Warmup
            wasm.matmul_f64_mt(N, N, N, ptrA, ptrB, ptrC);

            // Wait a bit for threads to settle
            await new Promise(r => setTimeout(r, 100));

            // Timed runs
            const times = [];
            for (let r = 0; r < rounds; r++) {
                const start = performance.now();
                wasm.matmul_f64_mt(N, N, N, ptrA, ptrB, ptrC);
                times.push(performance.now() - start);
            }

            // Copy result matrix C (refresh heap in case of memory growth)
            heap = wasm.getHeap();
            const C = new Float64Array(N * N);
            for (let i = 0; i < N * N; i++) {
                C[i] = heap[offsetC + i];
            }

            // Cleanup
            wasm.free_f64(ptrA);
            wasm.free_f64(ptrB);
            wasm.free_f64(ptrC);

            return {
                times,
                avg: times.reduce((a, b) => a + b) / times.length,
                C
            };
        }

        // Benchmark SSE-style multi-threaded WASM
        async function benchSSE_MT(wasm, N, A, B, rounds, nthreads) {
            wasm.set_num_threads(nthreads);

            const ptrA = wasm.malloc_f64(N * N);
            const ptrB = wasm.malloc_f64(N * N);
            const ptrC = wasm.malloc_f64(N * N);

            const offsetA = ptrA / 8;
            const offsetB = ptrB / 8;
            const offsetC = ptrC / 8;

            let heap = wasm.getHeap();
            for (let i = 0; i < N * N; i++) {
                heap[offsetA + i] = A[i];
                heap[offsetB + i] = B[i];
            }

            // Warmup
            wasm.matmul_sse_mt(N, N, N, ptrA, ptrB, ptrC);
            await new Promise(r => setTimeout(r, 100));

            const times = [];
            for (let r = 0; r < rounds; r++) {
                const start = performance.now();
                wasm.matmul_sse_mt(N, N, N, ptrA, ptrB, ptrC);
                times.push(performance.now() - start);
            }

            heap = wasm.getHeap();
            const C = new Float64Array(N * N);
            for (let i = 0; i < N * N; i++) {
                C[i] = heap[offsetC + i];
            }

            wasm.free_f64(ptrA);
            wasm.free_f64(ptrB);
            wasm.free_f64(ptrC);

            return {
                times,
                avg: times.reduce((a, b) => a + b) / times.length,
                C
            };
        }

        async function runBenchmark() {
            clearLog();

            const N = parseInt(document.getElementById('size').value);
            const threadSel = document.getElementById('threads').value;
            const nthreads = threadSel === 'auto' ? navigator.hardwareConcurrency : parseInt(threadSel);
            const rounds = parseInt(document.getElementById('rounds').value);
            const useWorker = document.getElementById('useWorker').checked;
            const gflop = 2 * N * N * N / 1e9;

            log('═'.repeat(70), 'highlight');
            log('  Multithreaded WASM MatMul Benchmark', 'highlight');
            log('═'.repeat(70), 'highlight');
            log('');
            log(`Matrix size: ${N}×${N}`, 'info');
            log(`FLOP per matmul: ${gflop.toFixed(3)} GFLOP`, 'info');
            log(`Threads: ${nthreads} (navigator.hardwareConcurrency = ${navigator.hardwareConcurrency})`, 'info');
            log(`Rounds: ${rounds}`, 'info');
            log(`Run WASM in Web Worker: ${useWorker ? 'YES' : 'NO'}`, 'info');
            log('');

            // Check SharedArrayBuffer
            if (typeof SharedArrayBuffer === 'undefined') {
                log('ERROR: SharedArrayBuffer not available!', 'warn');
                log('Multithreading requires COOP/COEP headers.', 'warn');
                log('Use: python3 server_mt.py', 'info');
                return;
            }

            // Generate random matrices
            log('Generating random matrices...', 'info');
            const A = new Float64Array(N * N);
            const B = new Float64Array(N * N);
            for (let i = 0; i < N * N; i++) {
                A[i] = Math.random();
                B[i] = Math.random();
            }

            const results = [];

            // Benchmark single-threaded
            log('');
            log('─'.repeat(60));
            log(`SINGLE-THREADED (1 thread)${useWorker ? ' - Web Worker' : ''}`, 'highlight');
            log('─'.repeat(60));

            try {
                let stResult;
                if (useWorker) {
                    setLoading(true, 'Loading WASM in Web Worker...');
                    await initWorker();
                    setLoading(true, 'Running benchmark in Web Worker...');
                    stResult = await benchWorker(N, A, B, rounds);
                } else {
                    setLoading(true, 'Loading single-threaded WASM...');
                    const stWasm = await loadSingleThreaded();
                    setLoading(true, 'Running single-threaded benchmark...');
                    stResult = await benchST(stWasm, N, A, B, rounds);
                }

                const stGflops = gflop / (stResult.avg / 1000);

                log(`Times: ${stResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${stResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${stGflops.toFixed(2)} GFLOPS`, 'result');

                const name = useWorker ? 'Single-threaded (Worker)' : 'Single-threaded';
                results.push({ name, time: stResult.avg, gflops: stGflops, threads: 1, C: stResult.C });
            } catch (e) {
                log(`Error: ${e.message}`, 'warn');
                log('Make sure matmul_full_4x4.wasm exists (run build_variants.sh)', 'info');
                console.error(e);
            }

            // Benchmark multi-threaded
            log('');
            log('─'.repeat(60));
            log(`MULTI-THREADED (${nthreads} threads)`, 'highlight');
            log('─'.repeat(60));

            try {
                setLoading(true, 'Loading multi-threaded WASM...');
                const mtWasm = await loadMultiThreaded();
                setLoading(true, `Running multi-threaded benchmark (${nthreads} threads)...`);

                const mtResult = await benchMT(mtWasm, N, A, B, rounds, nthreads);
                const mtGflops = gflop / (mtResult.avg / 1000);

                log(`Times: ${mtResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${mtResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${mtGflops.toFixed(2)} GFLOPS`, 'result');

                results.push({ name: `Multi-threaded (${nthreads}T)`, time: mtResult.avg, gflops: mtGflops, threads: nthreads, C: mtResult.C });
            } catch (e) {
                log(`Error: ${e.message}`, 'warn');
                log('Make sure to build with: ./build_mt.sh', 'info');
                log('And serve with: python3 server_mt.py', 'info');
                console.error(e);
            }

            // Benchmark SSE-style multi-threaded
            log('');
            log('─'.repeat(60));
            log(`SSE-STYLE MULTI-THREADED (${nthreads} threads)`, 'highlight');
            log('─'.repeat(60));
            log('Pre-duplicated B packing - no extract_lane+splat', 'info');

            try {
                setLoading(true, 'Loading SSE-style multi-threaded WASM...');
                const sseMtWasm = await loadSSE_MT();
                setLoading(true, `Running SSE-style MT benchmark (${nthreads} threads)...`);

                const sseMtResult = await benchSSE_MT(sseMtWasm, N, A, B, rounds, nthreads);
                const sseMtGflops = gflop / (sseMtResult.avg / 1000);

                log(`Times: ${sseMtResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${sseMtResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${sseMtGflops.toFixed(2)} GFLOPS`, 'result');

                results.push({ name: `SSE-style MT (${nthreads}T)`, time: sseMtResult.avg, gflops: sseMtGflops, threads: nthreads, C: sseMtResult.C });
            } catch (e) {
                log(`Error: ${e.message}`, 'warn');
                log('Make sure to build with: ./build_sse_mt.sh', 'info');
                console.error(e);
            }

            // Benchmark numwa BLAS (single-threaded, for comparison)
            log('');
            log('─'.repeat(60));
            log('NUMWA BLAS PACKAGE (single-threaded)', 'highlight');
            log('─'.repeat(60));

            try {
                setLoading(true, 'Loading numwa BLAS module...');
                const numwa = await loadNumwaModule();

                // Standard kernel
                setLoading(true, 'Running numwa standard kernel...');
                const numwaStdResult = await benchNumwa(numwa, 'matmul_f64', N, A, B, rounds);
                const numwaStdGflops = gflop / (numwaStdResult.avg / 1000);

                log('');
                log('numwa Standard (OpenBLAS-style driver)', 'result');
                log(`Times: ${numwaStdResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${numwaStdResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${numwaStdGflops.toFixed(2)} GFLOPS`, 'result');
                results.push({ name: 'numwa Standard (ST)', time: numwaStdResult.avg, gflops: numwaStdGflops, threads: 1, C: numwaStdResult.C });

                // SSE-style kernel
                setLoading(true, 'Running numwa SSE-style kernel...');
                const numwaSSEResult = await benchNumwa(numwa, 'matmul_f64_sse', N, A, B, rounds);
                const numwaSSEGflops = gflop / (numwaSSEResult.avg / 1000);

                log('');
                log('numwa SSE-style (pre-duplicated B)', 'result');
                log(`Times: ${numwaSSEResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${numwaSSEResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${numwaSSEGflops.toFixed(2)} GFLOPS`, 'result');
                results.push({ name: 'numwa SSE (ST)', time: numwaSSEResult.avg, gflops: numwaSSEGflops, threads: 1, C: numwaSSEResult.C });

                // Native WASM kernel (i8x16.shuffle)
                setLoading(true, 'Running numwa Native kernel...');
                const numwaNativeResult = await benchNumwa(numwa, 'matmul_f64_native', N, A, B, rounds);
                const numwaNativeGflops = gflop / (numwaNativeResult.avg / 1000);

                log('');
                log('numwa Native (i8x16.shuffle)', 'result');
                log(`Times: ${numwaNativeResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${numwaNativeResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${numwaNativeGflops.toFixed(2)} GFLOPS`, 'result');
                results.push({ name: 'numwa Native (ST)', time: numwaNativeResult.avg, gflops: numwaNativeGflops, threads: 1, C: numwaNativeResult.C });

                // Standalone single-TU SSE (tests inlining hypothesis)
                setLoading(true, 'Running Standalone single-TU SSE...');
                const standalone = await loadStandaloneModule();
                const standaloneResult = await benchNumwa(standalone, 'matmul_standalone', N, A, B, rounds);
                const standaloneGflops = gflop / (standaloneResult.avg / 1000);

                log('');
                log('Standalone SSE (single-TU, full inlining)', 'result');
                log(`Times: ${standaloneResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${standaloneResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${standaloneGflops.toFixed(2)} GFLOPS`, 'result');
                results.push({ name: 'Standalone SSE (ST)', time: standaloneResult.avg, gflops: standaloneGflops, threads: 1, C: standaloneResult.C });
            } catch (e) {
                log(`Error: ${e.message}`, 'warn');
                log('numwa BLAS not available (build with: cd packages/numwa && npm run build:wasm)', 'info');
                console.error(e);
            }

            // Benchmark numwa BLAS MT (multi-threaded)
            log('');
            log('─'.repeat(60));
            log(`NUMWA BLAS MT (${nthreads} threads)`, 'highlight');
            log('─'.repeat(60));

            try {
                setLoading(true, 'Loading numwa BLAS MT module...');
                const numwaMT = await loadNumwaMTModule();

                // Standard MT kernel
                setLoading(true, `Running numwa MT standard kernel (${nthreads} threads)...`);
                const numwaMTStdResult = await benchNumwaMT(numwaMT, 'matmul_f64_mt', N, A, B, rounds, nthreads);
                const numwaMTStdGflops = gflop / (numwaMTStdResult.avg / 1000);

                log('');
                log('numwa Standard MT (OpenBLAS-style driver)', 'result');
                log(`Times: ${numwaMTStdResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${numwaMTStdResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${numwaMTStdGflops.toFixed(2)} GFLOPS`, 'result');
                results.push({ name: `numwa MT (${nthreads}T)`, time: numwaMTStdResult.avg, gflops: numwaMTStdGflops, threads: nthreads, C: numwaMTStdResult.C });

                // SSE-style MT kernel
                setLoading(true, `Running numwa MT SSE-style kernel (${nthreads} threads)...`);
                const numwaMTSSEResult = await benchNumwaMT(numwaMT, 'matmul_f64_sse_mt', N, A, B, rounds, nthreads);
                const numwaMTSSEGflops = gflop / (numwaMTSSEResult.avg / 1000);

                log('');
                log('numwa SSE-style MT (pre-duplicated B)', 'result');
                log(`Times: ${numwaMTSSEResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${numwaMTSSEResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${numwaMTSSEGflops.toFixed(2)} GFLOPS`, 'result');
                results.push({ name: `numwa SSE MT (${nthreads}T)`, time: numwaMTSSEResult.avg, gflops: numwaMTSSEGflops, threads: nthreads, C: numwaMTSSEResult.C });
            } catch (e) {
                log(`Error: ${e.message}`, 'warn');
                log('numwa BLAS MT not available (build with: cd packages/numwa && bash scripts/build-blas-mt.sh)', 'info');
                console.error(e);
            }

            // Benchmark Standalone MT (single-TU, tests inlining hypothesis)
            log('');
            log('─'.repeat(60));
            log(`STANDALONE SSE MT (${nthreads} threads)`, 'highlight');
            log('─'.repeat(60));
            log('Single translation unit - full inlining test', 'info');

            try {
                setLoading(true, 'Loading Standalone MT module...');
                const standaloneMT = await loadStandaloneMTModule();

                setLoading(true, `Running Standalone MT kernel (${nthreads} threads)...`);
                const standaloneMTResult = await benchNumwaMT(standaloneMT, 'matmul_standalone_mt', N, A, B, rounds, nthreads);
                const standaloneMTGflops = gflop / (standaloneMTResult.avg / 1000);

                log('');
                log('Standalone SSE MT (single-TU, full inlining)', 'result');
                log(`Times: ${standaloneMTResult.times.map(t => t.toFixed(1) + 'ms').join(', ')}`);
                log(`Average: ${standaloneMTResult.avg.toFixed(2)} ms`, 'result');
                log(`Performance: ${standaloneMTGflops.toFixed(2)} GFLOPS`, 'result');
                results.push({ name: `Standalone MT (${nthreads}T)`, time: standaloneMTResult.avg, gflops: standaloneMTGflops, threads: nthreads, C: standaloneMTResult.C });
            } catch (e) {
                log(`Error: ${e.message}`, 'warn');
                console.error(e);
            }

            setLoading(false);

            // Verify results match using error norm
            if (results.length >= 2 && results[0].C) {
                log('');
                log('─'.repeat(60));
                log('CORRECTNESS CHECK', 'highlight');
                log('─'.repeat(60));
                const ref = results[0].C;
                for (let i = 1; i < results.length; i++) {
                    if (results[i].C) {
                        const err = computeError(ref, results[i].C);
                        if (err < 1e-10) {
                            log(`${results[i].name}: relative error = ${err.toExponential(2)} ✓`, 'result');
                        } else if (err < 1e-6) {
                            log(`${results[i].name}: relative error = ${err.toExponential(2)} (acceptable)`, 'info');
                        } else {
                            log(`${results[i].name}: relative error = ${err.toExponential(2)} ✗`, 'warn');
                        }
                    }
                }
            }

            // Summary
            if (results.length >= 2) {
                log('');
                log('═'.repeat(70), 'highlight');
                log('  SUMMARY', 'highlight');
                log('═'.repeat(70), 'highlight');
                log('');

                log('Implementation'.padEnd(30) + 'Time (ms)'.padStart(12) + 'GFLOPS'.padStart(10) + 'Speedup'.padStart(10));
                log('─'.repeat(65));

                const baseline = results[0].time;
                const best = results.reduce((a, b) => a.gflops > b.gflops ? a : b);
                for (const r of results) {
                    const speedup = baseline / r.time;
                    const marker = r === best ? '★ ' : '  ';
                    log(marker + r.name.padEnd(28) + r.time.toFixed(2).padStart(12) + r.gflops.toFixed(2).padStart(10) + (speedup.toFixed(2) + 'x').padStart(10));
                }

                log('');
                const st = results.find(r => r.threads === 1);
                const mtResults = results.filter(r => r.threads > 1);

                if (st && mtResults.length > 0) {
                    log('MT vs ST comparison:', 'highlight');
                    for (const mt of mtResults) {
                        const speedup = st.time / mt.time;
                        const efficiency = speedup / mt.threads * 100;
                        log(`  ${mt.name}: ${speedup.toFixed(2)}x speedup (${efficiency.toFixed(1)}% efficiency)`, 'info');
                    }

                    // Compare SSE MT vs regular MT
                    const regularMT = results.find(r => r.name.includes('Multi-threaded') && !r.name.includes('SSE'));
                    const sseMT = results.find(r => r.name.includes('SSE-style'));
                    if (regularMT && sseMT) {
                        const sseSpeedup = regularMT.time / sseMT.time;
                        log('');
                        if (sseSpeedup > 1.01) {
                            log(`SSE-style is ${((sseSpeedup - 1) * 100).toFixed(1)}% faster than regular MT`, 'result');
                        } else if (sseSpeedup < 0.99) {
                            log(`SSE-style is ${((1 - sseSpeedup) * 100).toFixed(1)}% slower than regular MT`, 'warn');
                        } else {
                            log(`SSE-style and regular MT have similar performance`, 'info');
                        }
                    }

                    const bestMT = mtResults.reduce((a, b) => a.gflops > b.gflops ? a : b);
                    const bestSpeedup = st.time / bestMT.time;
                    if (bestSpeedup < 1.5) {
                        log('');
                        log('Note: Low speedup may be due to:', 'warn');
                        log('  • Matrix too small for threading overhead', 'info');
                        log('  • Thread pool not warmed up', 'info');
                        log('  • Try larger matrices (1000+) or more rounds', 'info');
                    }
                }

                log('');
                log(`Best: ${best.name} at ${best.gflops.toFixed(2)} GFLOPS`, 'highlight');
            }
        }
    </script>
</body>
</html>
