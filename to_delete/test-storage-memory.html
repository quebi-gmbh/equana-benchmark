<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Storage Memory Test</title>
    <style>
        body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
        pre { background: #0d0d1a; padding: 20px; overflow-x: auto; }
        button { margin: 5px; padding: 10px 20px; }
    </style>
</head>
<body>
    <h2>Storage Memory Test for Add12</h2>
    <p>Testing if writing to storage buffer preserves error terms in a single kernel</p>
    <button onclick="runTest()">Run Test</button>
    <pre id="output">Click button to run test...</pre>

    <script type="module">
        function log(msg) {
            document.getElementById('output').textContent += msg + '\n';
        }

        window.runTest = async function() {
            document.getElementById('output').textContent = '';

            // Generate two random f32 values
            const a = Math.fround(Math.random());
            const b = Math.fround(Math.random());

            log('=== Input Values (f32) ===');
            log(`a: ${a}`);
            log(`b: ${b}`);
            log('');

            // JavaScript reference
            const s_ref = a + b;
            const v_ref = s_ref - a;
            const r_ref = (a - (s_ref - v_ref)) + (b - v_ref);

            log('=== JavaScript Reference ===');
            log(`s = a + b:     ${s_ref}`);
            log(`v = s - a:     ${v_ref}`);
            log(`r:             ${r_ref}`);
            log(`s + r:         ${s_ref + r_ref}`);
            log('');

            // Check WebGPU
            if (!navigator.gpu) {
                log('WebGPU not available!');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
            if (!adapter) {
                log('No GPU adapter!');
                return;
            }

            const device = await adapter.requestDevice();

            // Single kernel writing intermediate values to storage buffer
            // The key is that storage buffer writes should be visible to subsequent reads
            const shaderCode = `
                @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                @group(0) @binding(2) var<storage, read_write> temp: array<f32>;
                @group(0) @binding(3) var<storage, read_write> output: array<f32>;

                @compute @workgroup_size(1)
                fn main() {
                    let a = inputA[0];
                    let b = inputB[0];

                    // Step 1: s = a + b - write to temp[0]
                    temp[0] = a + b;
                    storageBarrier();
                    let s = temp[0];

                    // Step 2: v = s - a - write to temp[1]
                    temp[1] = s - a;
                    storageBarrier();
                    let v = temp[1];

                    // Step 3: s - v - write to temp[2]
                    temp[2] = s - v;
                    storageBarrier();
                    let s_minus_v = temp[2];

                    // Step 4: a - (s - v) - write to temp[3]
                    temp[3] = a - s_minus_v;
                    storageBarrier();
                    let a_minus_smv = temp[3];

                    // Step 5: b - v - write to temp[4]
                    temp[4] = b - v;
                    storageBarrier();
                    let b_minus_v = temp[4];

                    // Step 6: r = (a-(s-v)) + (b-v) - write to temp[5]
                    temp[5] = a_minus_smv + b_minus_v;
                    storageBarrier();
                    let r = temp[5];

                    // Output final results
                    output[0] = s;
                    output[1] = r;
                    output[2] = v;
                    output[3] = s_minus_v;
                    output[4] = a_minus_smv;
                    output[5] = b_minus_v;
                }
            `;

            const shaderModule = device.createShaderModule({ code: shaderCode });

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                ]
            });

            const pipeline = device.createComputePipeline({
                layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                compute: { module: shaderModule, entryPoint: 'main' }
            });

            // Create buffers
            const inputA = device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            const inputB = device.createBuffer({
                size: 4,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
            });
            const tempBuffer = device.createBuffer({
                size: 8 * 4,  // 8 floats for temp storage
                usage: GPUBufferUsage.STORAGE,
            });
            const outputBuffer = device.createBuffer({
                size: 6 * 4,  // 6 floats
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            const readBuffer = device.createBuffer({
                size: 6 * 4,
                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
            });

            device.queue.writeBuffer(inputA, 0, new Float32Array([a]));
            device.queue.writeBuffer(inputB, 0, new Float32Array([b]));

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: inputA } },
                    { binding: 1, resource: { buffer: inputB } },
                    { binding: 2, resource: { buffer: tempBuffer } },
                    { binding: 3, resource: { buffer: outputBuffer } },
                ]
            });

            const commandEncoder = device.createCommandEncoder();
            const passEncoder = commandEncoder.beginComputePass();
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.dispatchWorkgroups(1);
            passEncoder.end();
            commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, 6 * 4);
            device.queue.submit([commandEncoder.finish()]);

            await readBuffer.mapAsync(GPUMapMode.READ);
            const result = new Float32Array(readBuffer.getMappedRange().slice(0));
            readBuffer.unmap();

            const s_gpu = result[0];
            const r_gpu = result[1];
            const v_gpu = result[2];
            const s_minus_v_gpu = result[3];
            const a_minus_smv_gpu = result[4];
            const b_minus_v_gpu = result[5];

            log('=== WebGPU Storage Buffer (Single Kernel) ===');
            log(`s = a + b:     ${s_gpu}`);
            log(`v = s - a:     ${v_gpu}`);
            log(`s - v:         ${s_minus_v_gpu}`);
            log(`a - (s-v):     ${a_minus_smv_gpu}`);
            log(`b - v:         ${b_minus_v_gpu}`);
            log(`r:             ${r_gpu}`);
            log('');

            log('=== Comparison ===');
            log(`s + r (GPU):   ${s_gpu + r_gpu}`);
            log(`a + b (true):  ${a + b}`);
            log('');

            if (r_gpu !== 0) {
                log('✓ SUCCESS: Error term r is non-zero!');
                log(`  Storage buffer writes prevent fast-math optimization.`);
            } else {
                log('✗ FAILURE: Error term r is still zero.');
                log(`  Fast-math is still eliminating the error term.`);
            }

            inputA.destroy();
            inputB.destroy();
            tempBuffer.destroy();
            outputBuffer.destroy();
            readBuffer.destroy();
            device.destroy();
        };
    </script>
</body>
</html>
