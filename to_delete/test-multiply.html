<!DOCTYPE html>
<html>
<head>
    <title>WebGPU Double-Double Multiply Test</title>
    <style>
        body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
        pre { background: #0d0d1a; padding: 20px; overflow-x: auto; }
        button { margin: 5px; padding: 10px 20px; }
    </style>
</head>
<body>
    <h2>Double-Double Arithmetic Test</h2>
    <p>Testing Add12, Mul12, Mul22 algorithms with WebGPU</p>
    <button onclick="runTest()">Run Test</button>
    <pre id="output">Click button to run test...</pre>

    <script type="module">
        function log(msg) {
            document.getElementById('output').textContent += msg + '\n';
        }

        // ============================================================
        // Double-Double Arithmetic in JavaScript (f64 reference)
        // ============================================================

        // Add12: Error-free addition
        // Returns (s, r) where a + b = s + r exactly
        function Add12_f64(a, b) {
            const s = a + b;
            const v = s - a;
            const r = (a - (s - v)) + (b - v);
            return { s, r };
        }

        // Split: Split a into high and low parts for Mul12
        // Uses Veltkamp splitting with factor 2^27 + 1
        function Split_f64(a) {
            const SPLIT_FACTOR = 134217729.0; // 2^27 + 1
            const c = SPLIT_FACTOR * a;
            const ahi = c - (c - a);
            const alo = a - ahi;
            return { hi: ahi, lo: alo };
        }

        // Mul12: Error-free multiplication
        // Returns (x, y) where a * b = x + y exactly
        function Mul12_f64(a, b) {
            const x = a * b;
            const { hi: ahi, lo: alo } = Split_f64(a);
            const { hi: bhi, lo: blo } = Split_f64(b);
            const err1 = x - (ahi * bhi);
            const err2 = err1 - (alo * bhi);
            const err3 = err2 - (ahi * blo);
            const y = (alo * blo) - err3;
            return { x, y };
        }

        // Mul22: Double-double multiplication
        // (ah, al) * (bh, bl) = (rh, rl)
        function Mul22_f64(ah, al, bh, bl) {
            const { x: t1, y: t2 } = Mul12_f64(ah, bh);
            const t3 = ((ah * bl) + (al * bh)) + t2;
            const { s: rh, r: rl } = Add12_f64(t1, t3);
            return { rh, rl };
        }

        // ============================================================
        // WebGPU Implementation
        // ============================================================

        window.runTest = async function() {
            document.getElementById('output').textContent = '';

            // Generate two random f64 values
            const a = Math.random();
            const b = Math.random();

            // True f64 product
            const true_product = a * b;

            log('=== Input Values ===');
            log(`a (f64): ${a}`);
            log(`b (f64): ${b}`);
            log(`True a*b: ${true_product}`);
            log('');

            // ========================================
            // JavaScript f64 Double-Double Test
            // ========================================
            log('=== JavaScript f64 Double-Double ===');

            // Split a and b into double-double representation
            const { s: a_h, r: a_l } = Add12_f64(a, 0); // a = a_h + a_l
            // Actually, for initial split we just use Math.fround approach
            const a_hi = Math.fround(a);
            const a_lo = a - a_hi;
            const b_hi = Math.fround(b);
            const b_lo = b - b_hi;

            log(`a split: hi=${a_hi}, lo=${a_lo}`);
            log(`b split: hi=${b_hi}, lo=${b_lo}`);
            log(`a reconstructed: ${a_hi + a_lo}`);
            log(`b reconstructed: ${b_hi + b_lo}`);
            log('');

            // Test Mul12 on single values
            const { x: mul12_x, y: mul12_y } = Mul12_f64(a, b);
            log('Mul12(a, b):');
            log(`  x (main): ${mul12_x}`);
            log(`  y (err):  ${mul12_y}`);
            log(`  x + y:    ${mul12_x + mul12_y}`);
            log(`  true:     ${true_product}`);
            log(`  error:    ${true_product - (mul12_x + mul12_y)}`);
            log('');

            // Test Mul22 with double-double inputs
            const { rh, rl } = Mul22_f64(a_hi, a_lo, b_hi, b_lo);
            log('Mul22(a.hi, a.lo, b.hi, b.lo):');
            log(`  rh (main): ${rh}`);
            log(`  rl (err):  ${rl}`);
            log(`  rh + rl:   ${rh + rl}`);
            log(`  true:      ${true_product}`);
            log(`  error:     ${true_product - (rh + rl)}`);
            log('');

            // ========================================
            // WebGPU Implementation
            // ========================================
            if (!navigator.gpu) {
                log('WebGPU not available!');
                return;
            }

            const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
            if (!adapter) {
                log('No GPU adapter!');
                return;
            }

            const device = await adapter.requestDevice();

            // WGSL shader implementing Add12, Split, Mul12, Mul22
            const shaderCode = `
                // Add12: Error-free addition
                // Returns (s, r) where a + b = s + r exactly
                fn Add12(a: f32, b: f32) -> vec2<f32> {
                    let s = a + b;
                    let v = s - a;
                    let r = (a - (s - v)) + (b - v);
                    return vec2<f32>(s, r);
                }

                // Split: Veltkamp splitting for Mul12
                fn Split(a: f32) -> vec2<f32> {
                    let SPLIT_FACTOR: f32 = 4097.0;  // 2^12 + 1 for f32 (12 = 24/2)
                    let c = SPLIT_FACTOR * a;
                    let ahi = c - (c - a);
                    let alo = a - ahi;
                    return vec2<f32>(ahi, alo);
                }

                // Mul12: Error-free multiplication
                fn Mul12(a: f32, b: f32) -> vec2<f32> {
                    let x = a * b;
                    let sa = Split(a);
                    let sb = Split(b);
                    let ahi = sa.x;
                    let alo = sa.y;
                    let bhi = sb.x;
                    let blo = sb.y;
                    let err1 = x - (ahi * bhi);
                    let err2 = err1 - (alo * bhi);
                    let err3 = err2 - (ahi * blo);
                    let y = (alo * blo) - err3;
                    return vec2<f32>(x, y);
                }

                // Mul22: Double-double multiplication
                // (ah, al) * (bh, bl) = (rh, rl)
                fn Mul22(ah: f32, al: f32, bh: f32, bl: f32) -> vec2<f32> {
                    let t = Mul12(ah, bh);
                    let t1 = t.x;
                    let t2 = t.y;
                    let t3 = ((ah * bl) + (al * bh)) + t2;
                    let result = Add12(t1, t3);
                    return result;
                }

                @group(0) @binding(0) var<storage, read> inputA: array<f32>;
                @group(0) @binding(1) var<storage, read> inputB: array<f32>;
                @group(0) @binding(2) var<storage, read_write> output: array<f32>;

                @compute @workgroup_size(1)
                fn main_simple(@builtin(global_invocation_id) id: vec3<u32>) {
                    // Simple f32 multiply
                    output[0] = inputA[0] * inputB[0];
                }

                @compute @workgroup_size(1)
                fn main_mul12(@builtin(global_invocation_id) id: vec3<u32>) {
                    // Mul12: a * b with error term
                    let result = Mul12(inputA[0], inputB[0]);
                    output[0] = result.x;  // main
                    output[1] = result.y;  // error
                }

                @compute @workgroup_size(1)
                fn main_mul22(@builtin(global_invocation_id) id: vec3<u32>) {
                    // Mul22: (a.hi, a.lo) * (b.hi, b.lo)
                    // inputA[0]=a.hi, inputA[1]=a.lo
                    // inputB[0]=b.hi, inputB[1]=b.lo
                    let result = Mul22(inputA[0], inputA[1], inputB[0], inputB[1]);
                    output[0] = result.x;  // rh
                    output[1] = result.y;  // rl
                }

                @compute @workgroup_size(1)
                fn main_add12(@builtin(global_invocation_id) id: vec3<u32>) {
                    // Add12: a + b with error term
                    let result = Add12(inputA[0], inputB[0]);
                    output[0] = result.x;  // sum
                    output[1] = result.y;  // error
                }

                @compute @workgroup_size(1)
                fn main_split(@builtin(global_invocation_id) id: vec3<u32>) {
                    // Split: a into hi/lo
                    let result = Split(inputA[0]);
                    output[0] = result.x;  // hi
                    output[1] = result.y;  // lo
                }
            `;

            const shaderModule = device.createShaderModule({ code: shaderCode });

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
                ]
            });

            const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });

            // Create pipelines for each entry point
            const pipelineSimple = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: 'main_simple' }
            });

            const pipelineMul12 = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: 'main_mul12' }
            });

            const pipelineMul22 = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: 'main_mul22' }
            });

            const pipelineAdd12 = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: 'main_add12' }
            });

            const pipelineSplit = device.createComputePipeline({
                layout: pipelineLayout,
                compute: { module: shaderModule, entryPoint: 'main_split' }
            });

            // Helper to run a compute shader
            async function runCompute(pipeline, inputAData, inputBData, outputSize) {
                const inputA = device.createBuffer({
                    size: inputAData.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                const inputB = device.createBuffer({
                    size: inputBData.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                });
                const outputBuffer = device.createBuffer({
                    size: outputSize * 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                });
                const readBuffer = device.createBuffer({
                    size: outputSize * 4,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
                });

                device.queue.writeBuffer(inputA, 0, inputAData);
                device.queue.writeBuffer(inputB, 0, inputBData);

                const bindGroup = device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        { binding: 0, resource: { buffer: inputA } },
                        { binding: 1, resource: { buffer: inputB } },
                        { binding: 2, resource: { buffer: outputBuffer } },
                    ]
                });

                const commandEncoder = device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(pipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.dispatchWorkgroups(1);
                passEncoder.end();
                commandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, outputSize * 4);
                device.queue.submit([commandEncoder.finish()]);

                await readBuffer.mapAsync(GPUMapMode.READ);
                const result = new Float32Array(readBuffer.getMappedRange().slice(0));
                readBuffer.unmap();

                inputA.destroy();
                inputB.destroy();
                outputBuffer.destroy();
                readBuffer.destroy();

                return result;
            }

            // ========================================
            // GPU Tests
            // ========================================
            log('=== WebGPU Tests ===');
            log('');

            // Test 1: Simple f32 multiply
            const f32_a = Math.fround(a);
            const f32_b = Math.fround(b);
            const simpleResult = await runCompute(
                pipelineSimple,
                new Float32Array([f32_a]),
                new Float32Array([f32_b]),
                1
            );
            log('1. Simple f32 multiply (GPU):');
            log(`   a (f32): ${f32_a}`);
            log(`   b (f32): ${f32_b}`);
            log(`   result:  ${simpleResult[0]}`);
            log(`   true:    ${true_product}`);
            log(`   error:   ${true_product - simpleResult[0]}`);
            log('');

            // Test 2: Split test
            const splitResult = await runCompute(
                pipelineSplit,
                new Float32Array([f32_a]),
                new Float32Array([0]),
                2
            );
            log('2. Split test (GPU):');
            log(`   input:   ${f32_a}`);
            log(`   hi:      ${splitResult[0]}`);
            log(`   lo:      ${splitResult[1]}`);
            log(`   hi + lo: ${splitResult[0] + splitResult[1]}`);
            log(`   diff:    ${f32_a - (splitResult[0] + splitResult[1])}`);
            log('');

            // Test 3: Add12 test
            const add12Result = await runCompute(
                pipelineAdd12,
                new Float32Array([f32_a]),
                new Float32Array([f32_b]),
                2
            );
            log('3. Add12 test (GPU):');
            log(`   a + b (f64): ${a + b}`);
            log(`   s (GPU):     ${add12Result[0]}`);
            log(`   r (GPU):     ${add12Result[1]}`);
            log(`   s + r:       ${add12Result[0] + add12Result[1]}`);
            log(`   error:       ${(a + b) - (add12Result[0] + add12Result[1])}`);
            log('');

            // Test 4: Mul12 test
            const mul12Result = await runCompute(
                pipelineMul12,
                new Float32Array([f32_a]),
                new Float32Array([f32_b]),
                2
            );
            log('4. Mul12 test (GPU):');
            log(`   a * b (f64): ${true_product}`);
            log(`   x (GPU):     ${mul12Result[0]}`);
            log(`   y (GPU):     ${mul12Result[1]}`);
            log(`   x + y:       ${mul12Result[0] + mul12Result[1]}`);
            log(`   error:       ${true_product - (mul12Result[0] + mul12Result[1])}`);
            log('');

            // Test 5: Mul22 test
            const mul22Result = await runCompute(
                pipelineMul22,
                new Float32Array([a_hi, a_lo]),
                new Float32Array([b_hi, b_lo]),
                2
            );
            log('5. Mul22 test (GPU):');
            log(`   (a.hi, a.lo) * (b.hi, b.lo)`);
            log(`   a.hi=${a_hi}, a.lo=${a_lo}`);
            log(`   b.hi=${b_hi}, b.lo=${b_lo}`);
            log(`   rh (GPU):    ${mul22Result[0]}`);
            log(`   rl (GPU):    ${mul22Result[1]}`);
            log(`   rh + rl:     ${mul22Result[0] + mul22Result[1]}`);
            log(`   true:        ${true_product}`);
            log(`   error:       ${true_product - (mul22Result[0] + mul22Result[1])}`);
            log('');

            // ========================================
            // Comparison Summary
            // ========================================
            log('=== Comparison Summary ===');
            const err_simple = Math.abs(true_product - simpleResult[0]);
            const err_mul12 = Math.abs(true_product - (mul12Result[0] + mul12Result[1]));
            const err_mul22 = Math.abs(true_product - (mul22Result[0] + mul22Result[1]));

            log(`Simple f32 error: ${err_simple.toExponential(4)}`);
            log(`Mul12 error:      ${err_mul12.toExponential(4)}`);
            log(`Mul22 error:      ${err_mul22.toExponential(4)}`);
            log('');
            log(`Mul12 improvement: ${(err_simple / err_mul12).toFixed(2)}x`);
            log(`Mul22 improvement: ${(err_simple / err_mul22).toFixed(2)}x`);

            device.destroy();
        };
    </script>
</body>
</html>
